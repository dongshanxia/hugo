<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mybatis on </title>
    <link>http://127.0.0.1:1313/hugo/tags/mybatis/</link>
    <description>Recent content in mybatis on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 08 Dec 2021 12:19:57 +0800</lastBuildDate><atom:link href="http://127.0.0.1:1313/hugo/tags/mybatis/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>java日志体系</title>
      <link>http://127.0.0.1:1313/hugo/java/mybatis/mybatis%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB/</link>
      <pubDate>Wed, 08 Dec 2021 12:19:57 +0800</pubDate>
      
      <guid>http://127.0.0.1:1313/hugo/java/mybatis/mybatis%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB/</guid>
      <description>java日志体系 常用日志框架
 Log4j：Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。 Log4j 2：Apache Log4j 2是Apache开发的一款Log4j的升级产品。 Commons Logging：Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta Commons Logging，后更名为Commons Logging。Apache推出了JCL（Jakarta Commons Logging），它只是定义了一套日志接口（其内部也提供一个Simple Log的简单实现），JCL也是一套接口规范，支持运行时动态加载日志组件的实现。也就是说，在应用程序代码中，只需调用Commons Logging的接口，底层实现可以是Log4j，也可以是JUL SLF4J：全称为Simple Logging Facade for Java，类似于Commons Logging，是一套简易Java日志门面，本身并无日志的实现。 Logback：是一套日志组件的实现，属于SLF4J阵营。 JUL：全称是Java Util Logging，是JDK1.4以后提供的日志实现。  mybatis日志体系 日志接口 定义了打印日志的级别
日志实现 配置日志框架的三种方式 1. 手动指定日志框架 1.先确定日志的Constructor对象
2.再利用Constructor对象和类名创建日志对象
3.打印日志的功能交给其他对象
2. 自动配置日志框架 如果不指定日志框架，mybatis也会尝试去找日志的实现
LogFactory中有静态代码块，会率先执行里面的代码，顺序执行（MyBatis查找日志框架的顺序为SLF4J→JCL→Log4j2→Log4j→JUL→No Logging），注意这里的run不是线程的run的概念，单纯只是匿名函数，传入Runnable对象，会执行它的run方法而已
比如会先执行第一个useSlf4jLogging 方法，如果找不到Slf4j对应的jar包，会抛出异常，但是不做任何处理，则继续执行下一个useCommonsLogging方法，如果找到了对应的jar包，会创建
Constructor对象在LogFactory对象里，然后继续执行tryImplementation、useLog4JLogging方法，每次都会判断Constructor对象为空，如果不为空则不会执行Runnable对象的run方法，从而实现自动确定日志框架。
3. 配置文件指定日志框架 项目启动时，会去读取mybatis配置文件，将logImpl的值set到configuration对象，如果有配置日志实现，configuration对象会在调用setLogImpl，来创建指定日志的Constructor对象
总结 三种配置日志框架的方法，了解怎么把日志实现交给mybatis，mybatis如何设置日志框架的， 日志框架设计的很巧妙，接口和实现完全分开来，用户可以随意搭配实现。</description>
    </item>
    
    <item>
      <title>mybatis拦截器执行过程</title>
      <link>http://127.0.0.1:1313/hugo/java/mybatis/mybatis%E6%8B%A6%E6%88%AA%E5%99%A8%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 08 Dec 2021 12:19:57 +0800</pubDate>
      
      <guid>http://127.0.0.1:1313/hugo/java/mybatis/mybatis%E6%8B%A6%E6%88%AA%E5%99%A8%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</guid>
      <description>m[toc]
mybatis的拦截器本人平时也很少用到，没了解之前，也只是知道运用到了动态代理用来增强方法的功能，但是不了解其中的原理。为了更好的使用mybatis，这次，我记录下我所了解的mybatis的原理，本文不一定完全正确，可能有理解不到位的地方。
1、使用mybatis的拦截器 像平常使用mybatis框架时，如果哪句sql报错了，我们可以通过控制台或日志打印的sql去查看sql的问题，但是如果sql有太多的参数，其实是很不方便的，自己还得手动去把一个一个参数给设置上，有些浪费时间，这时候就可以利用mybatis的拦截器去帮我们把参数给设置上。
 配置步骤
 1.创建拦截器 @Intercepts({ @Signature(type = StatementHandler.class, method = &amp;#34;query&amp;#34;, args = {Statement.class, ResultHandler.class}), @Signature(type = StatementHandler.class, method = &amp;#34;update&amp;#34;, args = {Statement.class}), @Signature(type = StatementHandler.class, method = &amp;#34;batch&amp;#34;, args = {Statement.class}) }) public class SlowSqlInterceptor implements Interceptor { @Override public Object intercept(Invocation invocation) throws InvocationTargetException, IllegalAccessException { // 主要逻辑 拼接参数到sql，并打印  } @Override public Object plugin(Object target) { // 创建代理对象  return Plugin.wrap(target, this); } @Override public void setProperties(Properties properties) { // 设置属性  } } /** * @author Clinton Begin */ public class Invocation { // 目标对象，即ParameterHandler、ResultSetHandler、StatementHandler或者Executor实例  private final Object target; // 目标方法，即拦截的方法  private final Method method; // 目标方法参数  private final Object[] args; public Invocation(Object target, Method method, Object[] args) { this.</description>
    </item>
    
    <item>
      <title>mybatis核心组件</title>
      <link>http://127.0.0.1:1313/hugo/java/mybatis/mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Wed, 08 Dec 2021 12:19:57 +0800</pubDate>
      
      <guid>http://127.0.0.1:1313/hugo/java/mybatis/mybatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</guid>
      <description>sequenceDiagram participant SqlSession participant Excutor participant StatementHandler participant parameterHandler participant ResultSetHandler participant TypeHandler participant ResultSet participant JDBC SqlSession-&amp;gt;&amp;gt;Excutor: Excutor-&amp;gt;&amp;gt;StatementHandler: StatementHandler--&amp;gt;&amp;gt;parameterHandler: StatementHandler--&amp;gt;&amp;gt;JDBC: parameterHandler--&amp;gt;&amp;gt;TypeHandler: parameterHandler-&amp;gt;&amp;gt;JDBC: JDBC-&amp;gt;&amp;gt;ResultSet: ResultSet--&amp;gt;&amp;gt;TypeHandler: ResultSet--&amp;gt;&amp;gt;ResultSetHandler: TypeHandler--&amp;gt;&amp;gt;ResultSetHandler: ResultSetHandler-&amp;gt;&amp;gt;StatementHandler: StatementHandler-&amp;gt;&amp;gt;Excutor: Excutor-&amp;gt;&amp;gt;SqlSession: Note left of SqlSession: asa flowchart TD subgraph configuration mappedStatement1 --&amp;gt; mappedStatement2 end configuration:
MyBatis框架的配置信息有两种，一种是配置MyBatis框架属性的主配置文件；另一种是配置执行SQL语句的Mapper配置文件。Configuration的作用是描述MyBatis主配置文件的信息
个人理解：
作为注册信息的载体，各种属性开关，Configuration组件还作为Executor、StatementHandler、ResultSetHandler、ParameterHandler组件的工厂类，用于创建这些组件的实例
excutor
Executor接口中定义了对数据库的增删改查方法，其中query()和queryCursor()方法用于执行查询操作，update()方法用于执行插入、删除、修改操作
MappedStatement
MyBatis通过MappedStatement描述&amp;lt;select|update|insert|delete&amp;gt;或者@Select、@Update等注解配置的SQL信息
StatementHandler
StatementHandler组件封装了对JDBC Statement的操作，例如设置Statement对象的fetchSize属性、设置查询超时时间、调用JDBC Statement与数据库交互等。
TypeHandler
处理JDBC类型与Java类型之间的转换
ParameterHandler
如果SQL语句中有参数占位符，在执行SQL语句之前，就需要为参数占位符设置值。ParameterHandler的作用是在PreparedStatementHandler和CallableStatementHandler操作对应的Statement执行数据库交互之前为参数占位符设置值
ResultSetHandler
ResultSetHandler用于在StatementHandler对象执行完查询操作或存储过程后，对结果集或存储过程的执行结果进行处理</description>
    </item>
    
    <item>
      <title>mybati缓存了解</title>
      <link>http://127.0.0.1:1313/hugo/java/mybatis/mybati%E7%BC%93%E5%AD%98%E4%BA%86%E8%A7%A3/</link>
      <pubDate>Wed, 08 Dec 2021 12:19:57 +0800</pubDate>
      
      <guid>http://127.0.0.1:1313/hugo/java/mybatis/mybati%E7%BC%93%E5%AD%98%E4%BA%86%E8%A7%A3/</guid>
      <description>mybatis的缓存 首先来看下mybatis对缓存的规范，规范嘛就是定义的接口啦。
缓存接口 ​	Cache接口 定义了缓存的方法
public interface Cache { /**获取缓存的id * @return The identifier of this cache */ String getId(); /**添加缓存 * @param key Can be any object but usually it is a {@link CacheKey} * @param value The result of a select. */ void putObject(Object key, Object value); /**根据缓存键获取缓存 * @param key The key * @return The object stored in the cache. */ Object getObject(Object key); /**移除缓存 * As of 3.</description>
    </item>
    
  </channel>
</rss>
